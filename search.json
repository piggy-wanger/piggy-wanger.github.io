[{"title":"LeetCode151 反转字符串中的单词","date":"2024-08-01T15:17:39.000Z","url":"/2024/08/01/020151/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["字符串","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 151. 反转字符串中的单词文档： 代码随想录——反转字符串中的单词编程语言： C++解题状态： 没思路… 思路解题的关键点在于先将整个字符串翻转过来。解题思路如下： 移除多余空格 将整个字符串反转 将每个单词反转 代码快慢指针法 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode541 反转字符串 II","date":"2024-08-01T15:16:01.000Z","url":"/2024/08/01/020541/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["字符串","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 541. 反转字符串 II文档： 代码随想录——反转字符串 II编程语言： C++解题状态： 解答错误，有一部分会缺少反转的次数 思路当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。本题考虑$2k$这个区间的边界就可以，不需要再根据剩余字符的个数再仔细讨论。 代码 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode344 反转字符串","date":"2024-08-01T15:13:15.000Z","url":"/2024/08/01/020344/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"],["字符串","/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 344. 反转字符串文档： 代码随想录——反转字符串编程语言： C++解题状态： 有思路，但是没动手操作 思路本题是双指针法，交换首尾的元素即可。 注意使用库函数的场合。 代码双指针法 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode383 赎金信","date":"2024-07-30T16:39:02.000Z","url":"/2024/07/31/020383/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["哈希表","/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 383. 赎金信文档： 代码随想录——赎金信编程语言： C++解题状态： 成功解决！ 思路记住口诀，要求快速判断集合是否某个元素时要考虑哈希表法。根据字母的固定数目，建立两个长度为26的数组，记录两个字符串中各个字母出现的次数，只要$randomNote$出现的任意字母的次数大于$magazine$那么就会返回$false$，反之返回$true$。 代码哈希表法 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode202 快乐数","date":"2024-07-30T16:37:31.000Z","url":"/2024/07/31/020202/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["哈希表","/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 202. 快乐数文档： 代码随想录——快乐数编程语言： C++解题状态： 忽略已知条件 思路无限循环即意味着会出现重复的数。当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了。 另外就是要关注如何快速准确求和。 代码哈希表法 时间复杂度： $O(logn)$ 空间复杂度： $O(logn)$ "},{"title":"LeetCode18 四数之和","date":"2024-07-30T16:35:32.000Z","url":"/2024/07/31/020018/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 18. 四数之和文档： 代码随想录——四数之和编程语言： C++解题状态： 想到了思路，但是考虑到时间复杂度太高，没敢尝试。 思路与三数之和是一个思路，不过要添加一个循环，分离出一个数出来，同时也要考虑$target$为任意值的情况。 代码双指针法 时间复杂度： $O(n^3)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode15 三数之和","date":"2024-07-30T16:33:13.000Z","url":"/2024/07/31/020015/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 15. 三数之和文档： 代码随想录——三数之和编程语言： C++解题状态： 没思路… 思路不可包含重复三元组的条件是本题最大的难点，本题的一大思路在与排序后进行去重。 代码双指针法 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode454 四数相加 II","date":"2024-07-27T08:44:55.000Z","url":"/2024/07/27/020454/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["哈希表","/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 454. 四数相加 II文档： 代码随想录——四数相加 II编程语言： C++解题状态： 思路错误 思路四个数组简单地使用$for$循环的话，时间复杂度就太高了，一种有效的方法就是化四为二，两两形成一个整体，再进行简单的处理。 代码哈希表 时间复杂度： $O(n^2)$ 空间复杂度： $O(n^2)$ "},{"title":"LeetCode1 两数之和","date":"2024-07-27T08:42:33.000Z","url":"/2024/07/27/020001/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["哈希表","/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 1. 两数之和文档： 代码随想录——两数之和编程语言： C++解题状态： 成功解决！ 思路思路一，朴实无华的双循环令人心里一暖。 思路二，哈希表法，使用$map$，计算后查询。先查询后添加的方法实在是耐人寻味。 代码方法一： 暴力解法 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ 方法二： 哈希表 时间复杂度： $O(n)$ 空间复杂度： $O(n)$ "},{"title":"LeetCode349 两个数组的交集","date":"2024-07-27T08:39:36.000Z","url":"/2024/07/27/020349/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["哈希表","/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 349. 两个数组的交集文档： 代码随想录——两个数组的交集编程语言： C++解题状态： 不了解集合使用，缺少高效思路 思路哈希法的简单应用。 代码哈希法 时间复杂度： $O(m+n)$ 空间复杂度： $O(n)$ "},{"title":"LeetCode242 有效的字母异位词","date":"2024-07-27T08:36:33.000Z","url":"/2024/07/27/020242/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["哈希表","/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 242. 有效的字母异位词文档： 代码随想录——有效的字母异位词编程语言： C++解题状态： 成功解答！ 思路问题的本质就是两个字符串是否包含相同的元素。字符串的元素都是小写的字母，那么元素的种类为26个，可以依次创建长度为26的数组，用来记录字符串中元素出现的次数。 代码哈希表 时间复杂度： $O(n)$ 空间复杂度： $O(S)$，字符集的大小，这里是26 "},{"title":"LeetCode160 相交链表","date":"2024-07-25T13:38:09.000Z","url":"/2024/07/25/020160/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"],["链表","/tags/%E9%93%BE%E8%A1%A8/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 160. 相交链表文档： 代码随想录——链表相交编程语言： C++解题状态： 没思路.. 思路依旧是双指针法，很巧妙的方法，有点想不出来。 代码先将两个链表末端对齐，然后两个指针齐头并进，容易判断出是否相交。 时间复杂度： $O(m + n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode24 两两交换链表中的节点","date":"2024-07-25T13:37:58.000Z","url":"/2024/07/25/020024/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["链表","/tags/%E9%93%BE%E8%A1%A8/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 24. 两两交换链表中的节点文档： 代码随想录——两两交换链表中的节点编程语言： C++解题状态： 没画图，被绕进去了… 思路思路还是挺清晰的，就是简单的模拟，但是一定要搞清楚交换的步骤，绕不清楚的时候最好画图来辅助解决问题。 代码 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode142 环形链表 II","date":"2024-07-25T13:36:25.000Z","url":"/2024/07/25/020142/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"],["链表","/tags/%E9%93%BE%E8%A1%A8/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 142. 环形链表 II文档： 代码随想录——环形链表 II编程语言： C++解题状态： 思路错误，链表不允许被修改 思路两步走，第一步，判断有没有环，第二步，判断入环口在哪边。 代码快慢指针法 第一步 定义两个指针，一个快指针，一个慢指针。快指针每次平移两个，慢指针每次平移一个。如果两个指针可以相遇，就代表有环。在一个环内，快速的移动肯定会经过慢速的移动 第二步 在两个指针的相遇处，令头节点和相遇节点相向而行，两个指针必定会相遇，并且相遇点就是环的入口。数学推理可见代码随想录讲解。 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode19 删除链表的倒数第N个结点","date":"2024-07-25T13:36:11.000Z","url":"/2024/07/25/020019/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"],["链表","/tags/%E9%93%BE%E8%A1%A8/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 19. 删除链表的倒数第N个结点文档： 代码随想录——删除链表的倒数第N个结点编程语言： C++解题状态： 成功解答！ 思路最直接的想法就是先获取到链表的整体长度，减去倒数的个数，正向查找。考虑完最直接的思路后就要考虑有没有优化的方法。双指针法在本题当中可以有非常巧妙的应用。 代码方法一： 暴力解法 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ 方法二： 双指针法如果要删除倒数第$n$个节点，则让$fast$先移动$n$步，然后再让$fast$和$slow$同时移动，直到$fast$指向链表末尾，删除$slow$所指向的节点就行。 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode206 反转链表","date":"2024-07-25T13:36:01.000Z","url":"/2024/07/25/020206/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"],["链表","/tags/%E9%93%BE%E8%A1%A8/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 206. 反转链表文档： 代码随想录——反转链表编程语言： C++解题状态： 有了思路以后没敢尝试 思路需要注意的是创建指针不会申请额外的内存空间。 代码方法一： 双指针法&#x2F;迭代我的理解是创建了三个指针，前中后各一个，进行滑动。先把$next$节点保存在后面的指针中，再把当前节点的$next$指针指向前面一个节点，然后一起平移这三个指针。 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ 方法二： 递归有点抽象，不是特别理解递归代表的具体含义，应该是封装了平移指针的操作。 时间复杂度： $O(n)$ 空间复杂度： $O(n)$，空间复杂度主要取决于递归调用的栈空间，最多为 n 层。 "},{"title":"LeetCode707 设计链表","date":"2024-07-25T13:35:49.000Z","url":"/2024/07/25/020707/","tags":[["C++","/tags/C/"],["链表","/tags/%E9%93%BE%E8%A1%A8/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 707. 设计链表文档： 代码随想录——设计链表编程语言： C++解题状态： 代码功底不够，只能写个大概 思路主要考察对链表结构的熟悉程度，对链表的增删改查，比较考验代码功底以及对链表的掌握。本题中的一些边界条件也要注意。 代码"},{"title":"LeetCode203 移除链表元素","date":"2024-07-25T13:32:31.000Z","url":"/2024/07/25/020203/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["链表","/tags/%E9%93%BE%E8%A1%A8/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 203.移除链表元素文档： 代码随想录——移除链表元素编程语言： C++解题状态： 解答错误，忘了链表的遍历是如何进行的了 思路对于链表的操作，最好可以给一个虚拟表头方便操作。另外需要注意的是，在删除链表的节点后，我们需要手动进行清理内存。 代码 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode59 螺旋矩阵II","date":"2024-07-24T14:57:02.000Z","url":"/2024/07/24/020059/","tags":[["C++","/tags/C/"],["数组","/tags/%E6%95%B0%E7%BB%84/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 59.螺旋矩阵II文档： 代码随想录——螺旋矩阵II编程语言： C++解题状态： 完全不会… 思路不考虑任何算法，单纯模拟，考察对代码的掌控。 代码顺时针画矩阵的过程为: 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 在边界条件非常多的情况下，一定要坚持循环不变量原则，按照固定规则进行遍历。在本题中，我们坚持左闭右开原则。 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode977 有序数组的平方","date":"2024-07-24T13:12:52.000Z","url":"/2024/07/24/020977/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"],["数组","/tags/%E6%95%B0%E7%BB%84/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 977.有序数组的平方文档： 代码随想录——有序数组的平方编程语言： C++解题状态： 完成，暴力解题 思路最简单的思路就是平方以后排序，其中平方的过程的时间复杂度为$O(n)$，整体的时间复杂度基本上取决于排序的时间复杂度。 其次还可以考虑双指针法。 代码方法一： 暴力排序这里我使用的排序法为时间复杂度$O(n^2)$的选择排序法。 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ 方法二： 双指针法数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode209 长度最小的子数组","date":"2024-07-24T13:12:43.000Z","url":"/2024/07/24/020209/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["数组","/tags/%E6%95%B0%E7%BB%84/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 209.长度最小的子数组文档： 代码随想录——长度最小的子数组编程语言： C++解题状态： 没有思路，暴力解法都没思路… 思路注意，子数组指的是连续子数组，不然本题就没有意义了。 代码方法一： 暴力解法所谓暴力解题，也要将时间复杂度控制在两个循环以内。 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ 方法二： 滑动窗口所谓滑动窗口就是不断调节子数组的起始位置和终止位置，以得到我们想要的结果。 滑动窗口需要确定以下几点： 窗口内的元素是什么？ 如何移动窗口的起始位置？ 如何移动窗口的终止位置？ 本题的关键在于根据当前子数组内的元素和，不断调整窗口的起始位置，降低时间复杂度。 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode27 移除元素","date":"2024-07-24T13:12:30.000Z","url":"/2024/07/24/020027/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["双指针法","/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"],["数组","/tags/%E6%95%B0%E7%BB%84/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 27.移除元素文档： 代码随想录——移除元素编程语言： C++解题状态： 错误，代码组织不严谨。 思路C++数组中的元素在内存地址上是连续的，不能真正地被移除，只能覆盖，因此只能考虑覆盖的方法。 代码方法一： 暴力解法暴力解题，第一个for循环遍历数组，第二个for循环更新数组。 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 方法二： 双指针法通过一个快指针和一个慢指针在一个循环内完成两个循环的工作。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ "},{"title":"LeetCode704 二分查找","date":"2024-07-24T12:42:29.000Z","url":"/2024/07/24/020704/","tags":[["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"],["数组","/tags/%E6%95%B0%E7%BB%84/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 704.二分查找文档： 代码随想录——二分查找编程语言： C++解题状态： 解答错误，变量定义位置错误。 思路有序数组的查找，最直接的思路应该就是二分查找。但是在查找的过程中要考虑到区间的边界问题，是左闭右开还是两边都闭。根据不同的情况来编写算法。注意，$middle$变量要放在$while$循环内来保证在每次循环时被有效更新。 代码 时间复杂度： $O(log n)$ "},{"title":"Web开发：React+Flask实现实时相机调用","date":"2024-07-19T12:51:51.000Z","url":"/2024/07/19/030002/","tags":[["Web开发","/tags/Web%E5%BC%80%E5%8F%91/"],["Flask","/tags/Flask/"],["React","/tags/React/"],["Python","/tags/Python/"],["TypeScript","/tags/TypeScript/"],["OpenCV","/tags/OpenCV/"]],"categories":[["Web开发","/categories/Web%E5%BC%80%E5%8F%91/"]],"content":"问题描述为了方便利用机器视觉算法，使用React+Flask前后端分离的办法实现实时相机的调用。由前端向后端请求视频流，后端接受请求后向前端发送视频流数据，方便在后端使用各种算法对视频流数据进行处理。 成功实现后，打开相机开关，即可在前端调用相机。 解决方法项目采用前后端分离架构，前端React+TypeScript，创建方法见我前面的一篇博文。Web开发：React+Flask前后端分离简介与初步实现。 frontend前端使用AntD提供的组件展示相机拍摄的视频，并使用axios库来与后端进行交互，向后端传递请求，获取视频流。 定义自己的相机展示组件CameraDisplay 注意，当组件 Switch 状态为 true 时，前端向后端获取的路由为 实际上可以设置 axios 的默认基础路由defaults.baseURL为 这样就可以将原来的路由简化为 将创建的自己的组件导入到主文件App.tsx中。 最后不要忘了在src目录下的index.tsx文件中设置默认路由 backend后端主要使用Flask-RESTful库来进行与前端的交互。后端相机稳定地输出到前端使用了threading.Lock()如果不使用的话，相机打开会卡顿，一段时间后就会自动关闭，如果有明白原理的大佬麻烦在评论区帮忙解答一下~ 首先是app.py文件 由于前端和后端使用的不是一个网络，所以跨域传输数据时，需要导入CORS允许跨域传输。 接着定义Flask-RESTful的Resource 最后需要相机的SDK文件camera.py来调用相机。 代码汇总完整的项目已经上传到本人的Github上，需要的朋友可以自取。  参考文献 Camera App with Flask and OpenCV Flask-RESTful官方文档 "},{"title":"Web开发：前后端分离的简介与初步实现","date":"2024-07-19T12:36:57.000Z","url":"/2024/07/19/030001/","tags":[["前后端分离","/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"],["Web开发","/tags/Web%E5%BC%80%E5%8F%91/"],["Flask","/tags/Flask/"],["React","/tags/React/"],["Python","/tags/Python/"],["TypeScript","/tags/TypeScript/"]],"categories":[["Web开发","/categories/Web%E5%BC%80%E5%8F%91/"]],"content":"前言本文主要简要介绍一下React+Flask的前后端分离开发实现。 前后端分离前后端分离是一种软件架构模式，旨在将一个应用程序的前端（用户界面）和后端（业务逻辑和数据处理）部分分开开发、管理和部署。这种模式的主要目标是提高开发效率、灵活性和可维护性，同时允许不同类型的开发团队专注于各自的领域。 在前后端分离架构中，前端和后端是独立的两个模块，它们通过网络通信进行交互。 前端 frontend 用户界面： 前端负责用户界面的展示，包括页面布局、交互元素、样式和用户体验。 开发技术： 前端可以使用各种技术，如HTML、CSS、JavaScript、框架（例如React、Vue.js、Angular）等来构建交互式的用户界面。 网络请求： 前端通过网络请求从后端获取数据，通常使用AJAX、Fetch API或类似的技术来进行异步通信。 后端 backend 业务逻辑： 后端负责应用程序的核心业务逻辑、数据处理、数据库交互和安全验证等。 开发技术： 后端开发可以使用不同的编程语言和框架，如Node.js、Python、Java、Ruby、Flask、Django等。 接口提供： 后端向前端提供API（Application Programming Interface），用于定义前后端之间的通信协议和数据交换格式（如JSON）。 前端框架：ReactReact简介React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它专注于构建高效、交互式和可重用的用户界面组件，使开发者能够轻松地构建复杂的 Web 应用。 组件化开发： React 鼓励开发者将用户界面分解为独立的可重用组件，每个组件都有自己的状态（state）和属性（props）。 虚拟 DOM： React 使用虚拟 DOM 来提高性能。它会在内存中创建一个虚拟表示，然后通过比较虚拟 DOM 的变化来最小化实际 DOM 的更新，从而提高页面渲染效率。 声明式编程： React 鼓励使用声明式方式描述 UI，开发者只需关注“什么”需要渲染，而不是“如何”渲染。 具体的React框架学习与入门，强烈推荐官方文档，提供中文版。 TypeScript简介TypeScript 是一种由微软开发的开源编程语言，它是 JavaScript 的一个超集。TypeScript 扩展了 JavaScript，添加了静态类型系统和一些其他编程特性，旨在增强代码的可维护性、可读性和开发时的错误检测能力。当结合TypeScript与React时，可以得到一种更加类型安全的开发体验。 后端框架：FlaskFlask 是一个基于 Python 的微型Web应用框架，旨在帮助开发者快速构建简单而灵活的Web应用程序。它被设计成非常轻量级，以便于扩展和自定义，同时提供了一些基本工具和结构，使得构建Web应用变得简单。 微型框架： Flask 是一个微型框架，它提供了一些基础功能，但不强迫开发者使用特定的工具或模块。这使得开发者可以根据项目的需求来选择性地添加功能和扩展。 路由： Flask 使用路由来映射 URL 到相应的视图函数。通过定义不同的路由规则，可以实现不同 URL 地址与不同处理逻辑的映射。 视图函数： 视图函数是处理 HTTP 请求的函数，它可以根据请求方法（GET、POST 等）来执行不同的操作，并返回响应内容。 模板引擎： Flask 集成了 Jinja2 模板引擎，允许开发者在视图函数中生成动态的 HTML 页面。模板引擎使得页面的渲染变得更加灵活和可维护。 上下文管理： Flask 提供了应用上下文和请求上下文来管理应用程序状态和请求相关的信息。这有助于在应用中共享数据，如数据库连接。 扩展： Flask 允许通过扩展（Extensions）来集成额外的功能，例如数据库集成、表单处理、身份验证等。这些扩展可以根据项目需求灵活地添加和定制。 RESTful 支持： Flask 可以很容易地实现 RESTful API，使得构建 Web 服务和移动应用后端变得方便。 总之，Flask 是一个非常适合小型至中型 Web 应用的框架，特点是灵活、简单、可扩展，适合那些希望快速构建原型或小规模应用的开发者。 Flask的入门学习强烈推荐李辉老师的教程：Flask 入门教程。 前后端分离初步实现整体架构 后端创建Flask项目 命令行创建： 或者直接PyCharm创建Flask项目。 app.py 在Flask程序中，我们引入了Flask-CORS扩展，来允许跨域传输，不然的话可能会报错。其他解决跨域传输的办法可以参考这篇文章： 3 Ways to Fix the CORS Error — and How the Access-Control-Allow-Origin Header Works 终端运行： 或者PyCharm直接点击运行Flask。 记录下Flask运行的端口号： 打开浏览器，输入： 我们可以看到： 前端命令行运行： 或者可以WebStorm&#x2F;PyCharm创建React项目，勾选上typescript选项。 向package.json文件中添加记录的端口号： App.tsx 使用了两个React中的hook函数，useState以及useEffect。 具体用法可以查阅官方文档。在上面的代码中，useState被用来将从后端获取到的数据传递给前端，useEffect被用来从后端获取数据。 终端运行： 实现效果 参考文献 How to connect ReactJS with flask API ? 3 Ways to Fix the CORS Error — and How the Access-Control-Allow-Origin Header Works此外，下面这篇文章也非常值得参考：React&#x2F;Flask Starter App "},{"title":"Ubuntu Tips：home目录下文件泄漏于桌面","date":"2024-07-19T12:33:50.000Z","url":"/2024/07/19/010002/","tags":[["Linux","/tags/Linux/"],["Ubuntu","/tags/Ubuntu/"]],"categories":[["Ubuntu使用","/categories/Ubuntu%E4%BD%BF%E7%94%A8/"]],"content":"问题描述不知道什么原因，Ubuntu重启后，home目录下文件全部显示在桌面上。 解决办法命令行解决办法crtl+alt+t打开终端，依次执行： 这时，可以看到如下画面： 输入 i 进入编辑： 通过键盘，移动光标到对应位置，将文件中的内容替换为上图中的内容。 注意! 第一个坑来了！ 上面文件中的地址字符串使用的地址可能是下图中的地址，更改后可能依旧会出现问题，无法打开桌面、图片等文件夹，会出现无法显示这一位置，符号连接的层数过多的错误。 所以需要将地址改为&#x2F;home&#x2F;user的格式。修改结束以后，按下ctrl+c，结束编辑。 最后再输入 :wq 退出编辑。 第二个坑！ 此时，千万不要直接重启电脑，不然配置文件会回到编辑之前的状态。这个时候我们需要删除我们修改路径的文件，比如桌面、图片、音乐、公共的文件夹，然后再分别新建。完成以后，在终端输入 大功告成！ 图形界面解决办法Step 1 勾选上显示隐藏文件夹。 Step 2 找到.config文件夹，打开，找到user-dirs.dirs文件，打开。 直接在文件中修改，将文件内容替换为上面给出的内容。 保存。 最后一个坑！ 成功以后最好在每个文件夹下新建一个文件，不然还是会出现出现无法显示这一位置，符号连接的层数过多的错误。 参考文献 ubuntu桌面被删除或home文件跑到桌面问题 Linux符号连接的层数过多 "},{"title":"Ubuntu Tips：单击任务栏图标缩放窗口","date":"2024-07-19T12:31:29.000Z","url":"/2024/07/19/010001/","tags":[["Linux","/tags/Linux/"],["Ubuntu","/tags/Ubuntu/"]],"categories":[["Ubuntu使用","/categories/Ubuntu%E4%BD%BF%E7%94%A8/"]],"content":"问题描述Ubuntu22.04在点击左侧的任务栏图标时，无法像Windows那样交替实现最大最小化。 解决办法下载Dconf编辑器在Ubuntu Software中下载Dconf编辑器。 导航路径打开编辑器后，连续打开文件夹，导航至&#x2F;org&#x2F;gnome&#x2F;shell&#x2F;extensions&#x2F;dash-to-dock 路径。 设置自定义值取消使用默认值后，根据自己的偏好选择自定义值。 一般来说，选择 minimize-or-previews 符合Windows用户的使用习惯，当然你也可以选择其他的自定义值。 参考资料 在 Ubuntu 下实现单击任务栏图标最小化窗口的功能 "},{"title":"Noor","date":"2024-05-20T05:14:20.000Z","url":"/2024/05/20/noor/","categories":[[" ",""]],"content":" All my love is for Peng Nuo."},{"title":"About Me","date":"2024-07-19T12:28:10.000Z","url":"/about/index.html","categories":[[" ",""]]},{"title":"categories","date":"2024-07-19T12:27:39.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"Search","date":"2024-07-19T12:26:06.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2024-07-19T12:26:59.000Z","url":"/tags/index.html","categories":[[" ",""]]}]