[{"title":"LeetCode59 螺旋矩阵II","date":"2024-07-24T14:57:02.000Z","url":"/2024/07/24/0105/","tags":[["LeetCode","/tags/LeetCode/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 59.螺旋矩阵II文档： 代码随想录——螺旋矩阵II编程语言： C++解题状态： 完全不会… 思路不考虑任何算法，单纯模拟，考察对代码的掌控。 代码顺时针画矩阵的过程为: 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 在边界条件非常多的情况下，一定要坚持循环不变量原则，按照固定规则进行遍历。在本题中，我们坚持左闭右开原则。 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode977 有序数组的平方","date":"2024-07-24T13:12:52.000Z","url":"/2024/07/24/0104/","tags":[["LeetCode","/tags/LeetCode/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 977.有序数组的平方文档： 代码随想录——有序数组的平方编程语言： C++解题状态： 完成，暴力解题 思路最简单的思路就是平方以后排序，其中平方的过程的时间复杂度为$O(n)$，整体的时间复杂度基本上取决于排序的时间复杂度。 其次还可以考虑双指针法。 代码方法一： 暴力排序这里我使用的排序法为时间复杂度$O(n^2)$的选择排序法。 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ 方法二： 双指针法数组其实是有序的， 只不过负数平方之后可能成为最大数了。 那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode209 长度最小的子数组","date":"2024-07-24T13:12:43.000Z","url":"/2024/07/24/0103/","tags":[["LeetCode","/tags/LeetCode/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 209.长度最小的子数组文档： 代码随想录——长度最小的子数组编程语言： C++解题状态： 没有思路，暴力解法都没思路… 思路注意，子数组指的是连续子数组，不然本题就没有意义了。 代码方法一： 暴力解法所谓暴力解题，也要将时间复杂度控制在两个循环以内。 时间复杂度： $O(n^2)$ 空间复杂度： $O(1)$ 方法二： 滑动窗口所谓滑动窗口就是不断调节子数组的起始位置和终止位置，以得到我们想要的结果。 滑动窗口需要确定以下几点： 窗口内的元素是什么？ 如何移动窗口的起始位置？ 如何移动窗口的终止位置？ 本题的关键在于根据当前子数组内的元素和，不断调整窗口的起始位置，降低时间复杂度。 时间复杂度： $O(n)$ 空间复杂度： $O(1)$ "},{"title":"LeetCode27 移除元素","date":"2024-07-24T13:12:30.000Z","url":"/2024/07/24/0102/","tags":[["LeetCode","/tags/LeetCode/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 27.移除元素文档： 代码随想录——移除元素编程语言： C++解题状态： 错误，代码组织不严谨。 思路C++数组中的元素在内存地址上是连续的，不能真正地被移除，只能覆盖，因此只能考虑覆盖的方法。 代码方法一： 暴力解法暴力解题，第一个for循环遍历数组，第二个for循环更新数组。 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 方法二： 双指针法通过一个快指针和一个慢指针在一个循环内完成两个循环的工作。 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ "},{"title":"LeetCode704 二分查找","date":"2024-07-24T12:42:29.000Z","url":"/2024/07/24/0101/","tags":[["LeetCode","/tags/LeetCode/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["C++","/tags/C/"]],"categories":[["算法刷题","/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"]],"content":"前言 题目： 704.二分查找文档： 代码随想录——二分查找编程语言： C++解题状态： 解答错误，变量定义位置错误。 思路有序数组的查找，最直接的思路应该就是二分查找。但是在查找的过程中要考虑到区间的边界问题，是左闭右开还是两边都闭。根据不同的情况来编写算法。注意，$middle$变量要放在$while$循环内来保证在每次循环时被有效更新。 代码 时间复杂度： $O(log n)$ "},{"title":"Web开发：React+Flask实现实时相机调用","date":"2024-07-19T12:51:51.000Z","url":"/2024/07/19/0004/","tags":[["Web开发","/tags/Web%E5%BC%80%E5%8F%91/"],["Flask","/tags/Flask/"],["React","/tags/React/"],["OpenCV","/tags/OpenCV/"]],"categories":[["Web开发","/categories/Web%E5%BC%80%E5%8F%91/"]],"content":"问题描述为了方便利用机器视觉算法，使用React+Flask前后端分离的办法实现实时相机的调用。由前端向后端请求视频流，后端接受请求后向前端发送视频流数据，方便在后端使用各种算法对视频流数据进行处理。 成功实现后，打开相机开关，即可在前端调用相机。 解决方法项目采用前后端分离架构，前端React+TypeScript，创建方法见我前面的一篇博文。Web开发：React+Flask前后端分离简介与初步实现。 frontend前端使用AntD提供的组件展示相机拍摄的视频，并使用axios库来与后端进行交互，向后端传递请求，获取视频流。 定义自己的相机展示组件CameraDisplay 注意，当组件 Switch 状态为 true 时，前端向后端获取的路由为 实际上可以设置 axios 的默认基础路由defaults.baseURL为 这样就可以将原来的路由简化为 将创建的自己的组件导入到主文件App.tsx中。 最后不要忘了在src目录下的index.tsx文件中设置默认路由 backend后端主要使用Flask-RESTful库来进行与前端的交互。后端相机稳定地输出到前端使用了threading.Lock()如果不使用的话，相机打开会卡顿，一段时间后就会自动关闭，如果有明白原理的大佬麻烦在评论区帮忙解答一下~ 首先是app.py文件 由于前端和后端使用的不是一个网络，所以跨域传输数据时，需要导入CORS允许跨域传输。 接着定义Flask-RESTful的Resource 最后需要相机的SDK文件camera.py来调用相机。 代码汇总完整的项目已经上传到本人的Github上，需要的朋友可以自取。  参考文献 Camera App with Flask and OpenCV Flask-RESTful官方文档 "},{"title":"Web开发：前后端分离的简介与初步实现","date":"2024-07-19T12:36:57.000Z","url":"/2024/07/19/0003/","tags":[["前后端分离","/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"],["Web开发","/tags/Web%E5%BC%80%E5%8F%91/"],["Flask","/tags/Flask/"],["React","/tags/React/"]],"categories":[["Web开发","/categories/Web%E5%BC%80%E5%8F%91/"]],"content":"前言本文主要简要介绍一下React+Flask的前后端分离开发实现。 前后端分离前后端分离是一种软件架构模式，旨在将一个应用程序的前端（用户界面）和后端（业务逻辑和数据处理）部分分开开发、管理和部署。这种模式的主要目标是提高开发效率、灵活性和可维护性，同时允许不同类型的开发团队专注于各自的领域。 在前后端分离架构中，前端和后端是独立的两个模块，它们通过网络通信进行交互。 前端 frontend 用户界面： 前端负责用户界面的展示，包括页面布局、交互元素、样式和用户体验。 开发技术： 前端可以使用各种技术，如HTML、CSS、JavaScript、框架（例如React、Vue.js、Angular）等来构建交互式的用户界面。 网络请求： 前端通过网络请求从后端获取数据，通常使用AJAX、Fetch API或类似的技术来进行异步通信。 后端 backend 业务逻辑： 后端负责应用程序的核心业务逻辑、数据处理、数据库交互和安全验证等。 开发技术： 后端开发可以使用不同的编程语言和框架，如Node.js、Python、Java、Ruby、Flask、Django等。 接口提供： 后端向前端提供API（Application Programming Interface），用于定义前后端之间的通信协议和数据交换格式（如JSON）。 前端框架：ReactReact简介React 是一个用于构建用户界面的 JavaScript 库，由 Facebook 开发并维护。它专注于构建高效、交互式和可重用的用户界面组件，使开发者能够轻松地构建复杂的 Web 应用。 组件化开发： React 鼓励开发者将用户界面分解为独立的可重用组件，每个组件都有自己的状态（state）和属性（props）。 虚拟 DOM： React 使用虚拟 DOM 来提高性能。它会在内存中创建一个虚拟表示，然后通过比较虚拟 DOM 的变化来最小化实际 DOM 的更新，从而提高页面渲染效率。 声明式编程： React 鼓励使用声明式方式描述 UI，开发者只需关注“什么”需要渲染，而不是“如何”渲染。 具体的React框架学习与入门，强烈推荐官方文档，提供中文版。 TypeScript简介TypeScript 是一种由微软开发的开源编程语言，它是 JavaScript 的一个超集。TypeScript 扩展了 JavaScript，添加了静态类型系统和一些其他编程特性，旨在增强代码的可维护性、可读性和开发时的错误检测能力。当结合TypeScript与React时，可以得到一种更加类型安全的开发体验。 后端框架：FlaskFlask 是一个基于 Python 的微型Web应用框架，旨在帮助开发者快速构建简单而灵活的Web应用程序。它被设计成非常轻量级，以便于扩展和自定义，同时提供了一些基本工具和结构，使得构建Web应用变得简单。 微型框架： Flask 是一个微型框架，它提供了一些基础功能，但不强迫开发者使用特定的工具或模块。这使得开发者可以根据项目的需求来选择性地添加功能和扩展。 路由： Flask 使用路由来映射 URL 到相应的视图函数。通过定义不同的路由规则，可以实现不同 URL 地址与不同处理逻辑的映射。 视图函数： 视图函数是处理 HTTP 请求的函数，它可以根据请求方法（GET、POST 等）来执行不同的操作，并返回响应内容。 模板引擎： Flask 集成了 Jinja2 模板引擎，允许开发者在视图函数中生成动态的 HTML 页面。模板引擎使得页面的渲染变得更加灵活和可维护。 上下文管理： Flask 提供了应用上下文和请求上下文来管理应用程序状态和请求相关的信息。这有助于在应用中共享数据，如数据库连接。 扩展： Flask 允许通过扩展（Extensions）来集成额外的功能，例如数据库集成、表单处理、身份验证等。这些扩展可以根据项目需求灵活地添加和定制。 RESTful 支持： Flask 可以很容易地实现 RESTful API，使得构建 Web 服务和移动应用后端变得方便。 总之，Flask 是一个非常适合小型至中型 Web 应用的框架，特点是灵活、简单、可扩展，适合那些希望快速构建原型或小规模应用的开发者。 Flask的入门学习强烈推荐李辉老师的教程：Flask 入门教程。 前后端分离初步实现整体架构 后端创建Flask项目 命令行创建： 或者直接PyCharm创建Flask项目。 app.py 在Flask程序中，我们引入了Flask-CORS扩展，来允许跨域传输，不然的话可能会报错。其他解决跨域传输的办法可以参考这篇文章： 3 Ways to Fix the CORS Error — and How the Access-Control-Allow-Origin Header Works 终端运行： 或者PyCharm直接点击运行Flask。 记录下Flask运行的端口号： 打开浏览器，输入： 我们可以看到： 前端命令行运行： 或者可以WebStorm&#x2F;PyCharm创建React项目，勾选上typescript选项。 向package.json文件中添加记录的端口号： App.tsx 使用了两个React中的hook函数，useState以及useEffect。 具体用法可以查阅官方文档。在上面的代码中，useState被用来将从后端获取到的数据传递给前端，useEffect被用来从后端获取数据。 终端运行： 实现效果 参考文献 How to connect ReactJS with flask API ? 3 Ways to Fix the CORS Error — and How the Access-Control-Allow-Origin Header Works此外，下面这篇文章也非常值得参考：React&#x2F;Flask Starter App "},{"title":"Ubuntu Tips：home目录下文件泄漏于桌面","date":"2024-07-19T12:33:50.000Z","url":"/2024/07/19/0002/","tags":[["Linux","/tags/Linux/"],["Ubuntu","/tags/Ubuntu/"]],"categories":[["Ubuntu使用","/categories/Ubuntu%E4%BD%BF%E7%94%A8/"]],"content":"问题描述不知道什么原因，Ubuntu重启后，home目录下文件全部显示在桌面上。 解决办法命令行解决办法crtl+alt+t打开终端，依次执行： 这时，可以看到如下画面： 输入 i 进入编辑： 通过键盘，移动光标到对应位置，将文件中的内容替换为上图中的内容。 注意! 第一个坑来了！ 上面文件中的地址字符串使用的地址可能是下图中的地址，更改后可能依旧会出现问题，无法打开桌面、图片等文件夹，会出现无法显示这一位置，符号连接的层数过多的错误。 所以需要将地址改为&#x2F;home&#x2F;user的格式。修改结束以后，按下ctrl+c，结束编辑。 最后再输入 :wq 退出编辑。 第二个坑！ 此时，千万不要直接重启电脑，不然配置文件会回到编辑之前的状态。这个时候我们需要删除我们修改路径的文件，比如桌面、图片、音乐、公共的文件夹，然后再分别新建。完成以后，在终端输入 大功告成！ 图形界面解决办法Step 1 勾选上显示隐藏文件夹。 Step 2 找到.config文件夹，打开，找到user-dirs.dirs文件，打开。 直接在文件中修改，将文件内容替换为上面给出的内容。 保存。 最后一个坑！ 成功以后最好在每个文件夹下新建一个文件，不然还是会出现出现无法显示这一位置，符号连接的层数过多的错误。 参考文献 ubuntu桌面被删除或home文件跑到桌面问题 Linux符号连接的层数过多 "},{"title":"Ubuntu Tips：单击任务栏图标缩放窗口","date":"2024-07-19T12:31:29.000Z","url":"/2024/07/19/0001/","tags":[["Linux","/tags/Linux/"],["Ubuntu","/tags/Ubuntu/"]],"categories":[["Ubuntu使用","/categories/Ubuntu%E4%BD%BF%E7%94%A8/"]],"content":"问题描述Ubuntu22.04在点击左侧的任务栏图标时，无法像Windows那样交替实现最大最小化。 解决办法下载Dconf编辑器在Ubuntu Software中下载Dconf编辑器。 导航路径打开编辑器后，连续打开文件夹，导航至&#x2F;org&#x2F;gnome&#x2F;shell&#x2F;extensions&#x2F;dash-to-dock 路径。 设置自定义值取消使用默认值后，根据自己的偏好选择自定义值。 一般来说，选择 minimize-or-previews 符合Windows用户的使用习惯，当然你也可以选择其他的自定义值。 参考资料 在 Ubuntu 下实现单击任务栏图标最小化窗口的功能 "},{"title":"Noor","date":"2024-05-20T05:14:20.000Z","url":"/2024/05/20/noor/","categories":[[" ",""]],"content":" All my love is for Peng Nuo."},{"title":"About Me","date":"2024-07-19T12:28:10.000Z","url":"/about/index.html","categories":[[" ",""]]},{"title":"categories","date":"2024-07-19T12:27:39.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"tags","date":"2024-07-19T12:26:59.000Z","url":"/tags/index.html","categories":[[" ",""]]},{"title":"Search","date":"2024-07-19T12:26:06.000Z","url":"/search/index.html","categories":[[" ",""]]}]